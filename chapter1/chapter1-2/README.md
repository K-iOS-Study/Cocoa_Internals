**1.2 객체 정체성과 등가성**

**1.2.1 오브젝티브-C 객체와 메모리 구조**

프로세스의 가상 메모리 배치 구조는 다음과 같다.

| address     | segment              | 설명                                   |
| ----------- | -------------------- | ------------------------------------ |
| high Memory | 스택 (STACK) - 아래로 자란다 |                                      |
|             | 빈공간                  |                                      |
|             | 힙 (HEAP) - 위로 자란다    |                                      |
|             | 심벌 (BSS)             | 초기값이 없는 전역 변수<br/>(zero initialized) |
|             | 데이터 (DATA)           | 값이 정해진 전역 변수                         |
| ro_base->   | 텍스트 (TEXT)           | 프로그램 코드                              |

 objc-c에서 객체 인스턴스틑 항상 힙(HEAP) 영역에 만들어지며, 해당 힙 메모리 주소를 스택(STACK) 영역에 할당한 포인터로 접근한다. 

<br>
 포인터만으로 가리키는 주소가 유효한지 판단 할 수 없다. 이미 해제된 객체를 가리키고 있다면 그 포인터는 `위험한 포인터(dangling pointer)`가 된다. 그래서 객체에 대한 `참조 개수(reference count)`로 객체가 유효한지 판단한다.

<br>

1.1장의 Pen class로 객체 인스턴스를 만드는 과정을 살펴보자

`Pen *aPen = [[Pen alloc] init];`

Pen* 타입인 aPen은 `STACK` 영역에 만들어지고 `HEAP` 영역에 있는 인스턴스를 가리킨다. Pen이라는 class 자체는 프로그램이 로딩될 때 미리 `HEAP` 영역에 로드되어있다.

<br>

Pen클래스의 `-draw` 메서드는 클래스명과 메서드명이 합친 `Pen-draw` 와 같은 형태의 `SELECTOR`로 매핑되며, 구현 부분은 `TEXT` 영역에 기계어로 저장되어있다.

`SELECTOR`를 이용한 `message dispatch`는 1.4장에서 다시 이야기한다



> **클래스 객체 생성하기**
> 
> 클래스 객체는 +new 메서드 하나만 호출하는 방법과, +alloc 메서드와 -init 메서드를 두단계에 걸쳐 호출하는 방법이 있다.
> 
> 일반적으로 +alloc으로 객체 인스턴스를 힙 영역에 생성한 직후 -init 메서드로 아무 메서드를 넘기지않고 초기화 하는 경우, +new만 호출해도 NSObject가 +alloc과 -init을 모두 호출해준다.
> 
> Pen *aPen = [Pen new];
> 
> // 위 코드와 아래 코드는 똑같다.
> 
> Pen *aPen = [[Pen alloc] init];

<br>

**1.2.2 객체 정체성**

 객체 인스턴스가 생성되면 힙 영역을 차지하게 된다. 두 인스턴스를 만든 상황을 가정 해 보자.

```objectivec
Pen *aPen = [Pen new];Pen *bPen = [Pen new];
```

두 인스턴스는 고유한 메모리주소를 갖기 때문에 서로 다른 고유의 `정체성(identity)`을 가진다.

<br>

**동일한 객체 정체성**

 바로 다음줄에 `bPen = aPen;` 코드를 추가한다고 생각해보자. 그러면 두 포인터 주소는 같은 주소를 가리킨다. 즉 aPen 객체와 bPen객체의 정체성이 동일해진다. 이런경우 당연히 한쪽에서 값을 변경하면 다른 쪽도 같이 영향을 받는다. 그리고 `aPen == bPen`과 같은 비교문을 사용해도 주소가 같으므로 결과는 참이다.

<br>

**1.2.3 객체 등가성**

 객체 인스턴스는 각각 고유한 메모리를 차지하기 때문에, 동일한 데이터를 저장해도 각자 영역에 보관한다.

```objectivec
Pen *aPen = [Pen new];
aPen.color = blue
aPen.position = (10,20)
Pen *xPen = [Pen new];
xPen.color = blue
xPen.position = (10,20)
```

위와 같은 코드가 있다고 생각해보자, 두 인스턴스의 주소는 다르므로 서로 다른 정체성을 가진다, 즉 `동일한 객체가 아닌 것`이 명확하다.

하지만 두 인스턴스의 경우 `메모리에 저장하는 데이터가 동일`하다. 이런경우 `객체 속성에 대한 등가성`을 만족한다고 한다. 등가성을 만족하더라도 비교문은 성립하지 않는다.

```objectivec
aPen == xPen // false, 등가성을 만족해도 비교문은 성립하지않는다
```

대신 `-isEqual` 메서드를 구현해서 객체 인스턴스의 속성이 같은지 검사하도록 구현해야 한다.

<br>

Pen 클래스의 -isEqual 메서드를 구현하자면 다음과 같다.

```objectivec
- (BOOL)isEqual: (id)other{    return ([other isKindOfClass: [Pen class]] &&        other.position.x == _position.x &&        other.position.y == _position.y &&        [[other color] isEqual: _color])}
```

객체 인스턴스의 모든 속성이 동일해야 등가성을 갖는다고 한다.

<br>

**1.2.4 객체 예외성**

 모든 코코아 객체 인스턴스가 힙 영역에 생성되는 것은 아니다. 텍스트영역과 데이터 영역에 생기는 경우가 있다.

<br>

NSString 클래스는 NSObject에서 상속받은 코코아 클래스 중 유일하게 `전역 변수로 선언`이 가능하다.

힙 영역이 아니라 텍스트 영역에 문자열을 저장하고 인스턴스는 힙이 아닌 데이터영역에 고유한 주소를 차지한다.

```objectivec
NSString* aPenName = @"BluePen";NSString* bPenName = @"BluePen";
NSString* cPenName = @"BluePen";
```

만약 이처럼 동일한 문자열을 반복해서 사용할 경우 같은 텍스트 영역과 데이터 영역을 사용한다. 그래서 동일한 정체성을 가진다. 이런 방식을 `문자열 인터닝 (string interning)`이라 한다.

<br>

**스위프트 문자열**

스위프트의 String 객체는 네이티브 객체로 만들 수 있고, NSString을 사용 할 수도 있다. 네이티브 문자열은 내부적으로 인터닝을 사용하지 않고 텍스트 영역의 문자열을 OpaquePointer 포인터로 그대로 가리키는 형식을 사용한다. 즉 네이티브 문자열이 `좀 더 가벼운` 방식을 사용한다.

<br>

**1.2.5 -hash 메서드**

 앞에서 언급한 `-isEqual` 메서드를 재구현 한 경우, 반드시 `-hash` 메서드도 다시 구현해야 한다. 왜냐하면 NSDictionary같은 컬랙션은 내부적으로 -isEqual 대신 -hash를 사용하기 때문이다. NSObject의 최상위 class의 -hash는 그냥 메모리 주소값을 의미한다.

정체성은 다르지만 등가성이 성립하는 경우를 위해 -hash 메서드를 새로 구현해야 한다. -hash 메서드를 구현할 때도 -isEqual 처럼 모든 속성을 고려해서 해시값을 만들어주면 된다.

<br>

**스위프트 Hashable 프로토콜**

 스위프트는 객체뿐만 아니라 모든 타입의 Hashable 프로토콜을 구현해야한다. 프로토콜에는 hashValue() 함수와, ==() 함수가 필수이므로 이를 구현하면 된다.

<br>

**1.2.6 요약**

 객체 인스턴스와 클래스 자체는 메모리에 공간을 차지하고 고유한 정체성을 가진다, 서로 다른 정체성을 지니더라고 모든 속성이 같은 객체도 존재한다. 즉 등가성이 성립하는지 판단하기위해 == 연산을 사용해선 안되고 -isEqual과 -hash도 구현해야 컬랙션 내부에서 비교가 가능해진다.


