**자동 메모리 관리**

 예전에는 컴파일러가 실행 시점에 발생할 메모리 관련 문제들을 `정적 분석 기법(static analysis)`로 경고만 줄 뿐이었다. 요즘은 정적 분석 기법을 발전시켜 자동으로 메모리 관리를 도와주는 `ARC`라는 새로운 메모리 관리 방식을 제공한다.

<br>

**3.1 ARC(자동 참조 계산)**

 2010년 Xcode4부터 LLVM 컴파일러 C언어 계열 프런트엔드로 `Clang`을 공개했다. Clang은 C언어와 obj-C 소스코드를 컴파일하기 위해 만들어졌지만, 부가적으로 정적 분석 기능이 포함되었다. Xcode에서 정적 분석을 실행하면, Clang에서 소스를 분석하고 실행 시점에 발생할 수 있는 이슈를 찾아준다.

<br>

 2011년 obj-C 객체에 대한 자동 메모리 관리 방식인 `ARC(Automatic Reference Counting)`가 나왔다. ARC는 말 그대로 컴파일러가 개발자를 대신해 메모리 관리 코드를 작성해 주는 기술로, Clang 정적 분석 기술의 발전이 출시되는데 결정적인 역할을 했다.

<br>

**3.1.1 수동 참조 계산 방식과 비교**

 ARC를 사용한다고 기존과 다른 방식으로 바뀌는것은 아니다. 여전히 객체마다 참조 횟수가 있고, 객체 소유권에 대한 동일한 규칙을 기준으로 참조 계산을 한다. 

<br>

| 수동 참조 계산 코드 | ARC(자동 참조 계산 코드) |
| ----------- | ---------------- |
| alloc       | alloc            |
| init        | init             |
| doAction    | doAction         |
| retain      | -                |
| copy        | copy             |
| release     | -                |
| release     | -                |
| dealloc     | -                |

**3.1.2 ARC 규칙**

 ARC의 새로운 규칙을 알아보자. 위의 표와 같이 ARC는 retain, release코드가 필요 없다. 컴파일러가 자동으로 생명주기를 분석해서 retain, release 코드를 채워 넣기 때문이다. 최종 바이너리 코드에는 ARC방식 여부와 상관없이 거의 동일하다. ARC를 위한 규칙은 다음과 같다.

1. 메모리 관리 메서드를 구현하지 말라.

2. 객체 생성을 위한 메서드 이름 규칙을 따르라.

3. C구조체 내부에 객체 포인터를 넣지말라.

4. id와 void* 타입을 명시적으로 타입 변환하라.

5. NSAutoreleasePool대신 @autoreleasepool 블록 코드를 사용하라.

6. 메모리 지역(zone)을 사용하지 마라.

<br>

**규칙#1. 메모리 관리 메서드를 구현하지 말라**

 ARC 방식으로 작성하는 코드는 retain, release, retainCount, autorelease, dealloc 메서드를 구현해서도 안 되며, 호출해서도 안 된다. 컴파일러 경고가 발생하며, 경고가 없는 @selector(retain), @selector(release) 형태로 접근해서도 안 된다. ARC에서 retainCount값은 쓸모 없는 값이 들어있다고 생각하고 쓰지 말아야한다.

 `dealloc` 메서드도 직접 구현할 필요가 없고, 호출해서도 안된다. 특별히 dealloc에서 다른 동작을 해야한다면 (옵저버를 제거한다거나) 작성 할 수 있지만 [super dealloc] 코드를 넣지 말아야 한다.

 CFRetain, CFRelease 같은 함수들은 여전히 사용할 수 있다.

 <br>

**규칙#2. 객체 생성을 위한 메서드 이름 규칙을 따르라**

 참조 계산 규칙에 있는 소유권을 갖는 `alloc/new/copy/mutableCopy`로 시작하는 메서드는 ARC기반에서도 소유권을 갖는 것을 원칙으로 한다. 그 외에도 객체 생성을 위한 메서드를 작성할 때 이름 규칙을 따라야 한다.

 `init`으로 시작하는 인스턴스 메서드는 특혈하게 +alloc 메서드로 생성한 객체를 초기화해서 반환하는 용도로 사용해야만 한다. 객체 타입을 반환할 떄는 id 타입 대신에, 최근 Clang 컴파일러를 위해 instancetype 타입을 사용하기를 권장한다.

```objectivec
- (instancetype)initWithString:(NSString*)aStr;
```

<br>

**규칙#3. C 구조체 내부에 객체 포인터를 넣지마라**

 C언어에서 사용하는 struct나 union에 obj-c 객체 포인터를 넣으면 ARC에서 메모리 관리가 불가능하다. 컴파일러가 생명주기를 추적할 수 있어야 하는데, C구조체 내부는 컴파일러가 관리할 수 없어 컴파일 애러가 발생한다.

<br>

**규칙#4. id와 void* 타입을 명시적으로 타입 변환하라**

 기존의 obj-c에서는 id 타입과 void* 타입을 내부에서 당연하게 같은 타입으로 인식할 정도로 사용했다. ARC에서는 객체 생명주기를 관리하기 위해 타입 변환할 때 명시적으로 타입 변환 연산자를 사용해야만 한다. 상세한 내용은 '타입 연결' 부분을 참고하자.

<br>

**규칙#5. NSAutoreleasePool 대신 @autoreleasepool 블록을 사용하라**

 ARC환경에서는 블록이 끝나고 범위를 벗어날 때 해당 풀에 소유권이 있는 객체를 자동으로 해제한다. 만약 기존방식대로 작성한다면 컴파일 오류가 발생한다.

<br>

**규칙#6. 메모리 지역(zone)을 사용하지 마라**

2장에서 설명한 것처럼 런타임 구조를 변경하면서 zone은 더 이상 사용하지 않는다.

<br>

**3.1.3 소유권 수식어**

ARC 방식에서는 객체를 선언할 때 변수앞에 소유권 수식어가 다음과 같다.

- __strong

- __weak

- __unsafe_unretained

- __autoreleasing

<br>**strong 수식어**

아무 수식어를 입력하지 않았을 때 적용되는 기본 수식어다.

NSString* aString = [[NSString alloc] init];

NSString* __strong aString = [[NSString alloc] init];

두줄은 동일한 코드이다.

이 수식어의 의미는 해당 객체의 포인터를 (소유권을 갖고) 강하게 참조하고 있으므로 객체가 '살아있다'는 뜻이다. 앞으로 나올 '강한 참조'라는 단어는 이 수식어를 의미한다.

```objectivec
{
   NSString* __strong aString = [[NSString alloc] init];
   // [aString release];
}
```

이처럼 범위 내에서 객체를 생성해서 소유권을 갖고 있다가도 범위를 벗어날 경우에는 release가 없어도 소유권을 반환한다. 

<br>

**weak 수식어**

strong과 반대로 참조하는 객체가 살아있다는것을 보장하지 않는 '약한 참조'를 의미한다. 해당 객체를 참조하는 곳이 없으면 객체는 즉시 사라지고 포인터는 nil이 되어버린다.

<br>

**autoreleasing 수식어**

객체를 전달할 때 객체가 사라지지않으려면 항상 강한 참조를 사용해야할까?

코코아 프레임워크 내부에서 마든 객체를 넘겨받을 때는 이 지시어를 사용해서 자동 해제될 대상이라고 명시한다.

<br>

unsafe_unretained 수식어

weak 수식어와 마찬가지로 소유권을 갖지 않는 참조 관계는 비슷하다. 하지만 객체가 사라지면 nil로 바꿔주지도 않고 메모리 관리를 하지 않아서 안전하지도 않다. ARC 기반에서 객체 포인터를 일시적으로 참조만 하는경우 사용하기를 권한다.

<br>

**3.1.4 타입 연결**

코코아 프레임워크 내부에는 C언어로 만들어진 코어 파운데이션 프레임워크가 있다. NSArray나 NSString 같은 obc-c로 만든 객체도 내부 구현 코드는 코어 파운데이션 C 구조체를 사용한다.

코어 파운데이션에 있는 CFArrayRef나 CFString 구조체는 obj-c 객체 포인터로 타입 연결(bridge)할 수 있다. 물론 반대로도 가능하다.

이처럼 코어 파운데이션 구조체와 obj-c 객체 사이연결은 무비용 연결이라 부른다.

코어 그래픽스 처럼 C 언어 수준 API를 사용하는 경우에는 C 구조체 포인터를 사용할 수밖에 없다. 이경우 메모리 관리가 자동적으로 이뤄지지 않으며 CFRetain() 이나, CFRelease() 로 개발자가 직접 관리해야 한다.



1. bridge 방식
   객체의 소유권을 넘기지 않고 타입 연결만 하는 경우에 사용한다.

2. bridge_retained 또는 CFBridgingRetain 방식
   obj-c 객체를 코어 파운데이션 포인터로 연결하면서 소유권도 주는 경우에 사용한다.

3. bridge_transfer 또는 CFBridingRelease 방식
   
   2와는 반대로 코어 파운데이션 참조 포인터를 obj-c 객체로 연결하면서 소유권을 넘기는 경우에 사용한다.

4. 무비용 연결 타입
   코어 파운데이션 구조체와 파운데이션 객체는 무비용 연결이 가능하다, 가능 목록을 확인 해서 사용하자.

<br>

**3.1.5 프로퍼티와 인스턴스 변수**

클래스의 프로퍼티를 선언할 때 속성으로 지정하는 수식어와 ARC 소유권 수식어는 밀접한 관계를 가진다. 특히 인스턴스 변수를 미리 선언하는 경우 인스턴스 변수의 소유권 수식어를 프로퍼티 속성과 동일하게 맞춰야만 한다. 그렇지 않으면 컴파일 오류가 발생한다.



| 프로퍼티 수식어          | ARC 소유권 수식어         | 특징                   |
| ----------------- | ------------------- | -------------------- |
| copy              | _ strong            | 새로운 객체가 복사되고 소유권을 가짐 |
| assign            | _ unsafe_unretained | 값만 그대로 할당됨           |
| retain            | _ strong            | 소유권을 가짐              |
| strong            | _ strong            | 소유권을 가짐              |
| weak              | _ weak              | 약한 참조 (안전)           |
| unsafe_unretained | _ unsafe_unretained | 약한 참조 (불안전)          |

<br>

**3.1.6 요약**

 ARC를 사용하면 obc-c를 사용할 때 메모리를 자동으로 관리한다. 하지만 코드를 직접 작성하지 않을 뿐이지 내부에서 어떻게 동작하는지 이해해야 한다. 이를 이해하지 못하면 앱이 강제 종료되는 경우가 더 많아질 수 있다.

 코어 파운데이션 C 구조체를 사용하지 않고 obj-c 객체만으로 개발 할 수 있는 부분이 예전보다 많아졌지만, 소유권과 타입 연결에 대한 문제는 여전히 이슈가 되고 있다. 특히 스위프트와 c/c++ 코드를 연결하기 위해서는 obj-c 객체로 포장 해야 하는 경우가 있다.


